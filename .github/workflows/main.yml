# This is a basic workflow to help you get started with Actions

name: testmanualapproval

# Controls when the workflow will run
#on:
#  # Triggers the workflow on push or pull request events but only for the main branch
#  push:
#    branches: [ main ]
#  pull_request:
#    branches: [ main ]

on:

  pull_request:
    types: [ 'labeled','opened','synchronize','reopened']
    branches: [ 'main','dev','prod' ]
    paths: 
      - '**.tf'
      - '**.tfvars'
  
  pull_request_review:
    types: [submitted]   #edited
    branches: ['main','dev','prod']
    paths: 
      - '**.tf'
      - '**.tfvars'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      runinprod:
        description: 'Run on production'
        required: true
        default: 'No'
    
    #${{ github.event.inputs.runinprod =='' }}
        
# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    steps:
      - name: checkoutcode
        uses: actions/checkout@v2      
           
      - name: Setup gcp info
        env:
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_BILLING_ACCOUNT: ${{ secrets.GCP_BILLING_ACCOUNT }}
        run: |
          #cat << EOF >> ./run-modules/create-gke/terraform.tfvars
          cat << EOF >> ./terraform.tfvars

          gcp_project_id  = "$GCP_PROJECT_ID"
          billing_account = "$GCP_BILLING_ACCOUNT"
          EOF
          
      #- run: cat ./run-modules/create-gke/terraform.tfvars
      - run: cat ./terraform.tfvars
      
      - name: Setup TF token
        env:
          TFE_TOKEN: ${{ secrets.TFE_TOKEN }}
        run: |
          #cat << EOF > ./run-modules/create-gke/.terraformrc
          cat << EOF > ./.terraformrc
          {
             "credentials": {
               "app.terraform.io": {
                 "token": "$TFE_TOKEN"
                }
              }
          }
          EOF
          
      #- run: cat ./run-modules/create-gke/.terraformrc
      - run: cat ./.terraformrc
      
        # Runs Terraform init
      - name: Run a Terraform init on /modules/gke
        uses: docker://ghcr.io/ycit-team-terraformers/terraformers:v1
        env:
           TF_CLI_CONFIG_FILE: ./run-modules/create-gke/.terraformrc
           GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}       
        with:
          entrypoint: terraform
          #args: -chdir=./run-modules/create-gke/ init
          args: -chdir=./ init
          
        # Terraform validate: Runs terraform validate
      - name: Run a Terraform validate on /modules/gke
        uses: docker://ghcr.io/ycit-team-terraformers/terraformers:v1
        env:
           TF_CLI_CONFIG_FILE: ./run-modules/create-gke/.terraformrc
           GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
        with:
          entrypoint: terraform
          #args: -chdir=./run-modules/create-gke/ validate
          args: -chdir=./ validate
  
      # Terraform format
      - name: Run Terraform format on /modules/gke
        uses: docker://ghcr.io/ycit-team-terraformers/terraformers:v1
        env:
           GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
        with:
          entrypoint: terraform
          #args: -chdir=./run-modules/create-gke/ fmt
          args: -chdir=./ fmt
      
      # Linting of TF code
     
        # Runs a container from ghcr.io, version v0.33.1
      - name: Check linting of Terraform files for GKE
        uses: terraform-linters/tflint-bundle@v0.33.1
        # here are some options: loglevel to provide visibility, disable 1 TFLint default rule that was giving us Warning, and manually specify the location in the repo for TF files
        with:
          #args: --ignore-module=SOURCE --loglevel=info --disable-rule=terraform_deprecated_interpolation ./run-modules/create-gke/      
          args: --ignore-module=SOURCE --loglevel=info --disable-rule=terraform_deprecated_interpolation ./     
      
  terraform_plan:
  #if prebuildcheck passes, do TF plan
   runs-on: ubuntu-latest
   needs: build
   steps:
      # Checks-out repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout
        uses: actions/checkout@v2
      
      - name: Setup gcp info
        env:
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_BILLING_ACCOUNT: ${{ secrets.GCP_BILLING_ACCOUNT }}
        run: |
          #cat << EOF >> ./run-modules/create-gke/terraform.tfvars
          cat << EOF >> ./terraform.tfvars

          gcp_project_id  = "$GCP_PROJECT_ID"
          billing_account = "$GCP_BILLING_ACCOUNT"
          EOF
          
      # prepares Terraform token, to be able to donnect to TFC and download the Terraform modules specified in main-gke.tf source tag
      - name: Setup TF_token
        env:
          TFE_TOKEN: ${{ secrets.TFE_TOKEN }}
        run: |
          cat << EOF > ./run-modules/create-gke/.terraformrc
          {
             "credentials": {
               "app.terraform.io": {
                 "token": "$TFE_TOKEN"
                }
              }
          }
          EOF
          
      - name: Run Terraform init on /modules/gke
        uses: docker://ghcr.io/ycit-team-terraformers/terraformers:v1
        env:
           TF_CLI_CONFIG_FILE: ./run-modules/create-gke/.terraformrc
           GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
        with:
          entrypoint: terraform
          #args: -chdir=./run-modules/create-gke/ init
          args: -chdir=./ init

      - name: Run a Terraform plan on /modules/gke
        id: plan
        uses: docker://ghcr.io/ycit-team-terraformers/terraformers:v1
        env:
           TF_CLI_CONFIG_FILE: ./run-modules/create-gke/.terraformrc
           GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
        with:
          entrypoint: terraform
          #args: -chdir=./run-modules/create-gke/ plan
          args: -chdir=./ plan

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

  
      # Runs prod automatically if approved and prod label
      - name: Run prod
        if: github.event.review.state == 'approved' && contains(github.event.pull_request.labels.*.name, 'prod')  #||  ${{ github.event.label.name == 'prod' }}
        run: |
          echo "approved " ${{ github.event.label.name }}
          echo "${{ toJson(github.event.pull_request.labels.*.name) }}"

      # Runs automatically on DEV
      - name: Run dev
        if: (github.event_name == 'pull_request' || github.event_name == 'push') && ${{ github.event.label.name == 'dev' }}
        run: |
          echo if decision,
          echo test, should skip if run manual
          echo ${{ github.event.label.name }}
          echo "pull request labels:"
          echo "${{ toJson(github.event.pull_request.labels.*.name) }}"

      # Runs a set of commands using the runners shell
      - name: Run if contains run on dev
        #if: "!contains(toJSON(github.event.commits.*.message), ['skip-ci'])"
        if: "contains(github.event.head_commit.message, 'run on dev')"
        run: |
          echo should be skipped if manual run.
          echo test, should run only if commit message contains run on dev.
          #echo ${{ toJSON(github.event.commits.*.message) }}"
     
      # Runs on prod
      - name: Run if yes in manual run dispatch
        #if: ${{ github.event.inputs.runinprod }} =="yes"
        if: ${{ github.event.inputs.runinprod == 'yes' }}
        run: |
          echo Block run prod if manual run is yes,
          echo line 2 block run prod if manual run is yes, showing input value.
          echo ${{ github.event.inputs.runinprod }}
         
       # Runs on prod
      - name: Run if yes in manual run dispatch with format
        if: ${{ github.event.inputs.runinprod == 'no' }}
        run: |
          echo evaluate manual run if it is no,
          echo If manual run is yes, showing input value.
          echo ${{ github.event.inputs.runinprod }}
      
